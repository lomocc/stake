\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{RockX Liquid Staking Explained}
\author{RockX Team}

\begin{document}
\maketitle

\begin{abstract}
Staking, a cryptoeconomic primitive that allows participants to earn yield in exchange for locking tokens, has taken center stage over the past two years. Under Proof of Stake consensus mechanism, instead of using computational power, validators lock (“stake”) a certain amount of the network’s native cryptoasset as collateral to create new blocks. In return, they earn inflationary rewards and transaction fees.
\end{abstract}

\section{Introduction}

\subsection{What is Proof of Stake?}

Proof of Stake is the consensus protocol utilised in Ethereum 2.0 (ETH2). The consensus protocol helps everyone to know what transactions have been processed and in what order, which is known as validation.

ETH2 currently has a Proof of Stake (PoS) chain called the Beacon Chain, which is faster, more energy efficient and more decentralised than the current consensus protocol Ethereum is utilising (Proof of Work). Users deposit ETH and provide an Ethereum node to perform the required validation. As a reward for providing the node, the Beacon Chain gives node operators additional ETH on top of their deposits. These rewards are minted in return for helping secure the network.

\subsection{What is liquid staking?}

It is clear that PoS chains will be an integral part of the future of crypto, and become the foundation layer of which DeFi and metaverses will be built on.

However, PoS comes with some drawbacks for those wanting to participate directly as validators:

It requires technical know-how to set up and operate
32ETH is a significant barrier for regular token holders to participate in POS validation
Staked tokens are locked up and become illiquid assets
In order to solve these issues, liquid staking protocols were born. Liquid staking abstracts the depositing of tokens from running a validator node.

In exchange for their tokens, depositors receive a representative (uniETH) token from the protocol which is a claim on the tokens they have staked.

\subsection{What is uniETH?}

uniETH represents the staked ETH plus all future staking rewards. uniETH does not grow in quantity over time but instead, grows in value, i.e. 1 uniETH becomes worth increasingly more than 1 ETH.

\subsection{What should I stake with RockX instead of staking directly to ETH2?}

RockX removes several drawbacks that exist with Proof of Stake on ETH2.

The Beacon Chain requires a minimum deposit of at least 32 ETH. RockX will allow anyone to earn the reward on any amount of ETH deposited with us.

When depositing ETH on the Beacon Chain, users are required to have technical knowledge of interacting with smart contracts. RockX handles all interaction with the Beacon Chain in our users’ place. The Beacon Chain will also require users who make deposits to be technically proficient at running Ethereum nodes 24/7, at the same time keeping that node online and secure. RockX provides this service in our users’ place.

As ETH2 is being rolled out in several phases. We are currently in phase 1, the merge, and depositing now means your deposit is locked until phase 2 arrives, which could very well still be a long time away. With RockX you instantly get uniETH when depositing and do not need to be locked with us. It can be traded, sold or held at any time, which provides our users with liquidity on their staked ETH.

\subsection{What is the staking period for uniETH?}
The staking period to redeem the underlying ETH on uniETH will only be confirmed till ETH2 goes into phase 2. However, you will receive uniETH when you deposit and it will still gain staking rewards over time in terms of the token value. uniETH can also be sold and traded on various DEXs and CEXs if there is liquidity available for the trade.

\subsection{What is the minimum deposit?}
RockX gives everyone the opportunity to earn rewards on any amount of ETH, as we do not have a minimum. We do recommend a deposit of at least 0.01ETH to make your transaction worthwhile. When you stake ETH, you will receive uniETH, which gains rewards over time based on the performance of our nodes on the Beacon Chain.

\subsection{What is the maximum deposit?}
There is no limit on the amount of ETH you can stake with RockX on ETH2. The more ETH, the more rewards you will be receiving.

\section{RockX uniETH staking algorithm}

\subsection{Terminology}
\begin{description}
   \item[ETH] $1 ETH \equiv 10^{18}$
   \item[TotalSupply] Current total supply of uniETH.
   \item[TotalStaked] Total ethers staked to validators.
   \item[TotalDebts] Total unpaid debts(generated from \textbf{redeemFromValidators()}), awaiting to be paid by turn off validators to clean debts.
   \item[TotalPending] Pending ethers to be staked, usually $TotalPending <32ETH$
   \item[RewardDebts] The remaining ethers from debt clearance procedure.
   \item[AccountedUserRevenue] Overall net revenue which belongs to all uniETH holders.
   \item[ReportedValidators] Latest reported active validators.
   \item[ReportedValidatorBalance] Latest reported overall balance of active validator.
   \item[RecentReceived] The amount this contract receives recently.
   \item[CurrentReserve] Overall assets under management, given as:
   \[CurrentReserve = TotalPending + TotalStaked + AccountedUserRevenue - TotalDebts - RewardDebts\]
   \item[Exchange Ratio] Defined as symbol $\rho$ of uniETH to ETH, given as: 
    \[\rho = \frac{TotalSupply}{CurrentReserve} , \{normally: \rho \leq 1.0\} \]
\end{description}

\subsection{The algorithm explained}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\subsection{Function mint()}
For every mint operation, with \textbf{ethersToMint}, we have 

\begin{theorem}[Mint]
\label{Mint}
\[uniETH_{minted} := \rho \cdot ethersToMint \]
\[TotalSupply = TotalSupply^{\prime} + uniETH_{minted} \]
\[TotalPending = TotalPending^{\prime} + ethersToMint\]
\end{theorem}

\subsection{Function stake()}
At any time \textbf{TotalPending} has more than $32 ethers$, the manager can call \textbf{stake()} function, then \textbf{TotalPending} moves to \textbf{TotalStaked} and keeps \textbf{TotalPending} less than $32 ethers$, we calculate the changes as followings:
\begin{theorem}[Stake]
\label{Stake}
\[ethersToStake := \lfloor\frac{TotalPending^{\prime}}{32ETH}\rfloor \cdot 32ETH\]
\[TotalPending = TotalPending^{\prime} - ethersToStake \]
\[TotalStaked = TotalStaked^{\prime} + ethersToStake \]
\end{theorem}

\subsection{How ethers returns to this contract from validators? }
\label{sectionAccounting}

The way the withdrawals implementation is currently, withdrawals are not like normal transactions, and are instead system level transactions that update an account's balance without a transaction in or out. In our contract implementation, we use \textbf{accountedBalance} to track the in and out of the ethers, and compare \textbf{accountedBalance} with \textbf{this.balance}, the difference is the ethers reward returned from validators. We utilize variable \textbf{RecentReceived} to track this difference:

\[RecentReceived = accountedBalance - this.balance\]

As this variable will only be counted during reward distribution, the variable will be reset to 0 at the end of each \textbf{pushBeacon()} call.

\subsection{Function validatorStopped()}
Whenever a validator stopped by a node operator, the ethers are supposed to return to this contract, once the ethers returned, the oracle calls \textbf{validatorStopped()} function, with the following parameters:
\begin{description}
\item[valueStopped] The ethers sent-back from validators to the liquid staking contract.
\item[validatorStopped] The count of stopped validators.
\end{description}
Then, we have:

\begin{theorem}[validatorStopped]
\label{validatorStopped}
Suppose:

\[valueStopped \geq amountUnstaked \]

If we do not have \textbf{slashing}, then we have:

\[amountUnstaked := 32 ETH \cdot validatorStopped\]
\[incrRewardDebt := valueStopped - amountUnstaked\]

meanwhile, \textbf{RecentReceived} will be updated as explained in section:\ref{sectionAccounting}.
\[RecentReceived = RecentReceived^{\prime} + valueStopped\]

then, we use these 2 varaibles above to update the following variables:

\[RewardDebts = RewardDebt^{\prime} + incrRewardDebt\]
\[TotalPending = TotalPending^{\prime} + Max(0, amountUnstaked - TotalDebts) + incrRewardDebt\]
\[TotalStaked = TotalStaked^{\prime} -  amountUnstaked \]
\end{theorem}

\subsection{Function pushBeacon()}
An oracle service will push overall alive validators balance periodically, there're 2 things \textbf{pushBeacon()} do:
\subsubsection{adjusting reward base}
Firstly, pushBeacon will check if there is new validator alive, the reward base will be aligned to the new staked value plus previously reported validators balance, given:
\begin{description}
\item[aliveValidator] The count of validators alive
\end{description}
Then we have:
\begin{theorem}[pushBeacon]
\label{pushBeacon}
\[RewardBase = ReportedValidatorBalance + Max(0, aliveValidator - ReportedValidators) \cdot  32 ETH\]
\end{theorem}

\subsubsection{reward distribution}
Secondly, revenue will be accumulated as followings if there's any, given:
\begin{description}
\item[aliveBalance] The balance of current alive validators
\end{description}

Then we have:
\begin{theorem}[calcReward]
\label{calcReward}
\[r := Max(0, aliveBalance + RecentReceived - RewardBase)\]
\[AccountedUserRevenue = AccountedUserRevenue^{\prime} + r \cdot \frac{(1000 - managerFeeShare)}{1000}\]
\[RecentReceived = 0\]
\[ReportedValidators = aliveValidator\]
\[ReportedValidatorBalance = aliveBalance\]
\end{theorem}

\end{document}